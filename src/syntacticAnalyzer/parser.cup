package syntacticAnalyzer;

import java.io.FileInputStream;
import lexicalAnalyzer.Lexer;
import java.io.IOException;
import java.nio.file.Paths;
import java_cup.runtime.*;
import java.io.File;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the lexicalAnalyzer! */
init with {:
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    File file = new File(Paths.get("").toAbsolutePath().toString() + "/src/" + "input.txt");
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    lexer = new Lexer(f,fis);
:};

scan with {:
    return lexer.next_token();
:};

/* @@@@@@@@@@@@ terminals (tokens returned by the lexicalAnalyzer) @@@@@@@@@@@@ */

/* ID */
terminal      ID;
/* arithmetic operators */
terminal            PLUS,MINUS,MULTIPLY,DIVIDE;
terminal            DIV,MOD,SHL,SHR;
/* relational operators */
terminal      LT,LE,GT,GE,EQUAL,DIFF;
/* logic operators */
terminal            AND,NOT,OR;
/* symbols */
terminal      DOT,DOUBLEDOT,COMMA,COLON,SEMICOLON;
terminal      LPAR,RPAR,LBRA,RBRA;
terminal            CARET,ASSIGN,SIGN,SINGLEQUOTE,DOUBLEQUOTE;
/* types */
terminal char       CHARACTER;
terminal boolean  FALSE,TRUE;
terminal int        NUMINT;
terminal double   NUMREAL;
terminal String     STRINGCHARACTER,STRING;
/* type def */
terminal            BOOLEAN,CHAR,INTEGER,REAL;
/* reserved words */
terminal      ARRAY, ASM, BEGIN, CASE, CONST, CONSTRUCTOR, DESTRUCTOR, DO, DOWNTO, ELSE, END,
                    FILE, FOR, FOWARD, FUNCTION, GOTO, IF, IMPLEMENTATION, IN, INLINE, INTERFACE,
                    LABEL, NIL, OBJECT, OF, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, THEN,
                    TO, TYPE, UNIT, UNTIL, USES, VAR, WHILE, WITH, XOR;

/* @@@@@@@@@@@@ Non terminals @@@@@@@@@@@@ */

/* programHeading heading */
non terminal            program_heading,prog,block,id_list,next_id,label_declaration,label,type_definition_part;
/* Variables, procedure and functions declaration */
non terminal      variable_declaration_part,variable_declaration,next_variable_declaration;
/* Labels and Types */
non terminal      next_label,type,next_type_definition,type_definition,type_denoter,new_type,new_ordinal_type,array_type,
                        ordinal_type,next_ordinal_type;
non terminal      enumerated_type,subRange_type,constant,string,char,boolean;
/* procedure and Funciton Declaration */
non terminal      procedure_and_function_declaration_part,next_procedure_and_function_declaration,
                        procedure_or_function_declarationprocedure_declaration,function_declaration,procedure_heading,function_heading;
/* Parameter lists */
non terminal      formal_parameter_list,type_id,formal_parameter_section,next_formal_parameter_section;
/* Parameter Specification */
non terminal      value_parameter_specification,variable_parameter_specification,conformant_array_parameter_specification,
                  value_conformant_array_specification,variable_conformant_array_specification,conformant_array_schema,
                        index_type_specification,next_index_type_specification,identifier_or_conformant_array_schema;
/* Statements */
non terminal      compound_statement,statement_sequence,next_statement,statement,simple_or_structured_statement,
                    simple_statement,empty_statement,assignment_statement,variable_access,indexed_variable,expression_aux,
                  function_or_procedure_statement,actual_parameter_list,actual_parameter_aux,goto_statement,
                        structured_statement,if_statement,else_part,while_statement;
/* Expressions and Operator */
non terminal      expression,relational_operator,simple_expression,term_aux,term,signedfactor, unsignedfactor, factor_aux,
            factor,multiplying_operator,adding_operator,unsigned_constant;

/* Precedences */
precedence nonassoc ELSE;

/* @@@@@@@@@@@@ Grammar rules and syntatic evaluation @@@@@@@@@@@@ */

/* program */
prog ::= program_heading SEMICOLON block DOT;
program_heading ::= PROGRAM ID:id
                  | PROGRAM ID:id LPAR id_list RPAR;
/* identifier list */
id_list ::= ID:id next_id:il{:RESULT = new TypeID(il):};
next_id ::= COMMA ID:id next_id:il {:il = new ArrayList<String>();il.add(id):}
          | /*vazio*/ {:il.add(id):};

/* block */
block ::= label_declaration type_definition_part variable_declaration_part procedure_and_function_declaration_part compound_statement;

/* label */
label_declaration ::= LABEL label:lbl next_label:label_list SEMICOLON // lbl = label
                    | /*vazio*/; // optional
next_label ::= COMMA label next_label
             | /*vazio*/;
label ::= NUMINT:num {:RESULT = new UnsignedNumber(num);:};

/* Type Definition */
type_definition_part ::= TYPE type_definition:type_def SEMICOLON next_type_definition {:RESULT = new TypeDefinition(id,type_den):} // ?????
                       | /*vazio*/ ;            {:type_def_list.add(type_def):};
next_type_definition ::= type_definition:type_def SEMICOLON next_type_definition:type_def_list {:type_def_list = new ArrayList<String>();type_def_list.add(type_def):}
                       | /*vazio*/ {:type_def_list.add(type_def);:};
type_definition ::= ID:id EQUAL type_denoter:type_den{:RESULT = new TypeDefinition(id,type_den):};
type ::= INTEGER {: RESULT = PrimitiveType.INTEGER; :}
       | CHAR {: RESULT = PrimitiveType.CHAR; :}
       | STRING {: RESULT = PrimitiveType.STRING; :}
       | BOOLEAN {: RESULT = PrimitiveType.BOOLEAN; :};
type_denoter ::= ID:id {: RESULT = new TypeId(id); :}
               | type:type {: RESULT = type; :}
               | new_type:type {: RESULT = type; :};
new_type ::= new_ordinal_type:ordinalType {: RESULT = ordinalType; :}
           | subRange_type:subRangeType {: RESULT = subRangeType; :}
           | array_type:array {: RESULT = array; :};
array_type ::= ARRAY LBRA ordinal_type:ord next_ordinal_type:ordList RBRA OF type_denoter:typeDen {:RESULT = array :}; // ???
next_ordinal_type ::= COMMA ordinal_type:ord_type next_ordinal_type:ordinal_type_list
                    | /*vazio*/;
ordinal_type ::= new_ordinal_type:ordinal_type_list{:RESULT = new ordinal_type_list:}
               | type:type {:RESULT = type:};
               | ID : id {:RESULT = new TypeId(id):};
new_ordinal_type ::= enumerated_type:enumType {: RESULT = enumType; :}
                   | subRange_type:subRangeType {: RESULT = subRangeType; :};
enumerated_type ::= LPAR id_list:idList RPAR {: RESULT = new EnumeratedType(idList); :};
subRange_type ::= constant:const1 DOUBLEDOT constant:const2 {: RESULT = new SubrangeType(const1, const2); :};
constant ::= SIGN:sign NUMINT:num {:RESULT = new SignedNumber(sign,num):};
           | NUMINT               {:: }
           | boolean              {:RESULT = PrimitiveType.BOOLEAN:}
           | char                 {:RESULT = PrimitiveType.CHAR:};
boolean ::= TRUE
          | FALSE;
char ::= CHARACTER;
string ::= STRINGCHARACTER;

/* Variable Declaration */
variable_declaration_part ::= VAR variable_declaration:var_decl SEMICOLON next_variable_declaration:var_decl_list {:var_decl_list.add(var_decl);RESULT = new VariableDeclaration(var_decl,var_decl_list);:} //??????
                            | /*vazio*/; {:var_decl_list.add(var_decl);:}  
next_variable_declaration ::= variable_declaration:var_decl SEMICOLON next_variable_declaration:var_decl_list {:var_decl_list = new ArrayList<String>();var_decl_list.add(var_decl):}
                            | /*vazio*/; {:var_decl_list.add(var_decl);:}
variable_declaration ::= id_list:id COLON type_denoter:type_den {:RESULT = new VariableDeclaration(id,type_den):};

/* procedure and function Declaration */
procedure_and_function_declaration_part ::= procedure_or_function_declaration SEMICOLON next_procedure_and_function_declaration // ??????
                                           | /* vazio */;
next_procedure_and_function_declaration ::= procedure_or_function_declaration SEMICOLON next_procedure_and_function_declaration
                                          | /*vazio*/ ;
procedure_or_function_declaration ::= procedure_declaration // ?????
                                    | function_declaration;
procedure_declaration ::= procedure_heading:procedure_head SEMICOLON block:block; // ????
function_declaration ::= function_heading:function_head SEMICOLON block:block;
procedure_heading ::= PROCEDURE ID:id {:RESULT = new TypeId(id);:};
                    | PROCEDURE ID:id formal_parameter_list:formalP_list; // ??????
type_id ::= type:type {:RESULT = new TypeId(type):}
              | ID:id {:RESULT = new TypeId(id):};
function_heading ::= FUNCTION ID:id COLON type_id:type_id {:formalP_list.add(type_id); RESULT = new FunctionDesignator(id,formalP_list):}
                   | FUNCTION ID formal_parameter_list:formalP_list COLON type_id:type_id{:formalP_list = new ArrayList<String>();formalP_list.add(type_id):};

/* Parameter List and Section */
formal_parameter_list ::= LPAR formal_parameter_section next_formal_parameter_section RPAR;
next_formal_parameter_section ::= SEMICOLON formal_parameter_section next_formal_parameter_section
                                | /*vazio*/;
formal_parameter_section ::= value_parameter_specification
                           | variable_parameter_specification  //????
                           | conformant_array_parameter_specification:mechanism {:RESULT = new ConformantArrayParameter(mechanism,id,):};

/* Parameter and identifier Specification */
value_parameter_specification::= id_list:id COLON type_id:type_id {:RESULT = new FormalRef(id,type_id):}; 
variable_parameter_specification ::= VAR id_list:il COLON type_id:type_id {:RESULT = new FormalVar(id,type_id):};
conformant_array_parameter_specification ::= value_conformant_array_specification:value       {:RESULT = RefOrValue.val:}
                                           | variable_conformant_array_specification:variable {:RESULT = RefOrValue.Ref:};
value_conformant_array_specification::= id_list:il COLON conformant_array_schema:schema {::}; // ????
variable_conformant_array_specification ::= VAR id_list:il COLON conformant_array_schema:schema // ????
conformant_array_schema ::= ARRAY LBRA index_type_specification next_index_type_specification RBRA OF identifier_or_conformant_array_schema;
identifier_or_conformant_array_schema ::= type_id:id {:RESULT = new TypeId(id):}
                                        | conformant_array_schema:schema{:RESULT = new ConformantArraySchema():}; // ????
next_index_type_specification ::= SEMICOLON index_type_specification next_index_type_specification //????
                                | /*vazio*/;
index_type_specification ::= ID:id DOUBLEDOT ID:id COLON ID:id /*ordinal_type_identifier*/;

/* Compound statement */
compound_statement ::= BEGIN statement_sequence END {:RESULT = new CompoundStatement(stm_list):};
statement_sequence ::= statement:stm next_statement:stm_list {:stm_list.add(stm);:};
next_statement ::= SEMICOLON statement:stm next_statement:stm_list {:stm_list.add(stm);:}
                 | /*vazio*/{:stm_list = new ArrayList<String>();stm_list.add(stm);:};
statement ::= label:lbl COLON simple_or_structured_statement:simple_or_srtc_stm {:RESULT = new Statement();:}
empty_statement ::= /*vazio*/; {:RESULT = new EmptyStatement();:}
assignment_statement ::= variable_access:var_access ASSIGN expression:exp;
variable_access ::= ID:id  {:RESULT = new TypeId(id):}
                  | indexed_variable:index_variable {:RESULT = new IndexedVariable(var_access,exp_list):}; // ????
indexed_variable ::= variable_access:var_access LBRA expression:exp expression_aux:exp_list RBRA{:exp_list.add(exp):};
expression_aux ::= COMMA expression:exp expression_aux:exp_list{exp_list.add(exp)}
                 | /*vazio*/;{:exp_list = new ArrayList<String>();exp_list.add(exp);:};
function_or_procedure_statement ::= ID:id {:RESULT = new TypeId(id):}
                                  | ID:id actual_parameter_list:actualP_list{:RESULT = new ProcedureStatement(id,actualP_list_aux);:};
actual_parameter_list ::= LPAR expression:exp actual_parameter_aux:actualP_list_aux RPAR {:actualP_list_aux.add(exp):}
actual_parameter_aux ::= COMMA expression:exp actual_parameter_aux:actualP_list_aux {:actualP_list_aux.add(exp):}
                       | /*vazio*/{:actualP_list_aux = new ArrayList<String>();actualP_list_aux.add(exp);:};
goto_statement ::= GOTO label:lbl{:RESULT = new GotoStatement(lbl):};

/* Structured statement */
structured_statement ::= compound_statement {:RESULT = new CompoundStatement(stm_list):}
                       | if_statement:if_stm       {:RESULT = new IfStatement(exp_condition,if_stm,else_stm):} 
                       | while_statement:while_stm;    {:RESULT = WhileStatement(exp,stm);:};
if_statement ::= IF expression:exp_condition THEN statement:if_stm        {:RESULT = new Statement(if_stm):}
               | IF expression:exp THEN statement:ifthen_stm else_part:else_part {:RESULT = new Statement(ifthen_stm):};
else_part ::= ELSE statement:else_stm {:RESULT = new Statement(else_stm);:}; // ?????
while_statement ::= WHILE expression:exp DO statement:stm; {:RESULT = WhileStatement(exp,stm);:};
/* expression */
expression ::= simple_expression:simple_exp // ?????
             | expression:exp relational_operator:relational_oper simple_expression:simple_exp;
simple_expression ::= simple_expression:simple_exp adding_operator:add_oper term:term
                    | SIGN term:term
                    | term:term;
term ::= term:term multiplying_operator:mult_oper factor:fator
       | factor:fator;

factor ::= variable_access
         | unsigned_constant
         | ID actual_parameter_list
         | LPAR expression RPAR
         | NOT factor;

/* Operator */
multiplying_operator ::= MULTIPLY {:RESULT = BinaryArithmeticOperator.TIMES:}
                       | DIVIDE {:RESULT = BinaryArithmeticOperator.DIV:}
                       | MOD  {:RESULT = BinaryArithmeticOperator.MOD:}
                       | AND  {:RESULT = BinaryBooleanOperator.AND:};

adding_operator ::= PLUS      {:RESULT = BinaryArithmeticOperator.PLUS:}
                  | MINUS     {:RESULT = BinaryArithmeticOperator.MINUS:}
                  | OR        {:RESULT = BinaryBooleanOperator.OR:};

relational_operator ::= LT    {:RESULT = RelationalOperator.LT:}
                      | LE    {:RESULT = RelationalOperator.LTE:}
                      | GT    {:RESULT = RelationalOperator.GT:}
                      | GE    {:RESULT = RelationalOperator.GTE:}
                      | EQUAL {:RESULT = RelationalOperator.EQ:}
                      | DIFF; {:RESULT = RelationalOperator.NEQ:};

unsigned_constant ::= NUMINT:num {:RESULT = new UnsignedNumber(num);:}
                    | string : str {:RESULT = Str:}
                    | char;  {:RESULT = PrimitiveType.CHAR:};