/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package SintaxAnalizer;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};
/* Terminals (tokens returned by the scanner). */
terminal            PLUS, MINUS, MULTIPLY, DIVIDE, SIGN; // operadores aritmeticos
terminal			DOT, DOUBLEDOT, COMMA, COLON, SEMICOLON, CARET, ASSIGN; 
terminal 			LPAR, RPAR, LBRA, RBRA, SINGLEQUOTES;
terminal 			LT,LE,GT,GE,EQUAL,DIFF;
terminal			ID,CHR,STR,COMMENT;
terminal			AND, ARRAY, ASM, BEGIN, BOOLEAN, CASE, CHAR, CONST, CONSTRUCTOR, DESTRUCTOR, 
					DIV, DO, DOWNTO, ELSE, END, FALSE, FILE, FOR, FOWARD, FUNCTION, GOTO,
					IF, IMPLEMENTATION, IN, INLINE, INTEGER, INTERFACE, LABEL, MOD, NIL, NOT, 
					OBJECT, OF, OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, SHL, SHR, 
					STRING, THEN, TO, TRUE, TYPE, UNIT, UNTIL, USES, VAR, WHILE, WITH, XOR;
terminal Integer    NUMINT;        // our scanner provides numbers as integers
terminal float  	NumReal;

/* Non terminals */
non terminal            expr_list,Program_Heading,Prog,Block,Id_List,Label_Declaration_Part,Type_Definition_Part;
non terminal 			Variable_Declaration_Part,Procedure_And_Function_Part,Procedure_and_Function_Declaration_Part,Procedure_and_Function_Declaration_aux,Compound_Statement;
non terminal			Label_Declaration_aux,Type_Definition_aux,Type_Definition,Type_Denoter,New_Type,New_Ordinary_Type,Array_Type,Ordinal_Type,Ordinal_Type_aux;
non terminal 			New_Ordinal_Type,Enumerated_Type,SubRange_Type,Constant,Character_String,String_Element,String_Element_aux,String_Character,Variable_Declaration,Variable_Declaration_aux; 			
non terminal			Sign_aux, Id_List_aux;
non terminal Integer    expr;      // used to store evaluated subexpressions

/* Precedences */
precedence nonassoc RBRA;	// Inserted by Eclipse plugin
precedence nonassoc SEMICOLON;	// Inserted by Eclipse plugin
precedence left PLUS,MINUS;
precedence left MULTIPLY,DIVIDE;

/* The grammar rules */
Prog ::= Program_Heading SEMICOLON Block DOT;

Program_Heading ::= PROGRAM ID | LPAR Id_List RPAR;

Id_List ::= ID Id_List_aux;
Id_List_aux ::= COMMA ID Id_List_aux | /*vazio*/ ;

Block ::= Label_Declaration_Part 
		| Type_Definition_Part Variable_Declaration_Part Procedure_And_Function_Part Compound_Statement;

Label_Declaration_Part ::= LABEL ID Label_Declaration_aux SEMICOLON | /*vazio*/; // optional
Label_Declaration_aux ::= COMMA ID Label_Declaration_aux | /*vazio*/ ;

Type_Definition_Part ::= TYPE Type_Definition SEMICOLON Type_Definition_aux | /*vazio*/ ;
Type_Definition_aux ::= Type_Definition SEMICOLON Type_Definition_aux | /*vazio*/ ;
Type_Definition ::= ID EQUAL Type_Denoter;
Type_Denoter ::= ID | New_Type;
New_Type ::= New_Ordinary_Type | Array_Type;
Array_Type ::= ARRAY LBRA Ordinal_Type Ordinal_Type_aux RBRA OF Type_Denoter;
Ordinal_Type_aux ::= COMMA Ordinal_Type Ordinal_Type_aux | /*vazio*/;
Ordinal_Type ::= New_Ordinal_Type | ID;
New_Ordinal_Type ::= Enumerated_Type | SubRange_Type;
Enumerated_Type ::= LPAR Id_List RPAR;
SubRange_Type ::= Constant DOUBLEDOT Constant;
Constant ::= Sign_aux NUMINT | Character_String;
Sign_aux::= SIGN | /*vazio*/ ;
Character_String ::= SINGLEQUOTES String_Element String_Element_aux SINGLEQUOTES; // string element ? 
String_Element_aux::= String_Character String_Element_aux | /*vazio*/;
String_Character::= CHAR;

Variable_Declaration_Part ::= VAR Variable_Declaration SEMICOLON Variable_Declaration_aux | /*vazio*/;
Variable_Declaration_aux ::= Variable_Declaration SEMICOLON Variable_Declaration_aux | /*vazio*/;
Variable_Declaration ::= Id_List COLON Type_Denoter;

Procedure_and_Function_Declaration_Part ::= Procedure_and_Function_Declaration_aux | /*vazio*/ ;
Procedure_and_Function_Declaration_aux ::= Procedure_Declaration Procedure_and_Function_Declaration_aux 
				| Function_Declaration Procedure_and_Function_Declaration_aux | /*vazio*/ ;
Procedure_Declaration ::= Procedure_Heading SEMICOLON Block;
Function_Declaration ::= Function_Heading SEMICOLON Block;

Procedure_Heading ::= Procedure Id | Formal_Parameter_List;
Function_Heading ::= Function Id | Formal_Parameter_List Colon Result_Type;

Formal_Parameter_List ::= LPar Formal_Parameter_Section Formal_Parameter_Section_aux RPar;
Formal_Parameter_Section_aux ::= SemiColon Formal_Parameter_Section | Formal_Parameter_Section_aux |/*vazio*/ ;
Formal_Parameter_Section ::= Value_Parameter_Specification | Variable_Parameter_Specification | Conformant_Array_Parameter_Specification;

Value_Parameter_Specification::= Id_List Colon Id;
Variable_Parameter_Specification ::= Var Id_List Colon Id;
Conformant_Array_Parameter_Specification ::= Value_Conformant_Array_Specification | Variable_Conformant_Array_Specification;
Value_Conformant_Array_Specification::= Id_List Colon Conformant_Array_Schema; 
Variable_Conformant_Array_Specification ::= Var Id_List Colon Conformant_Array_Schema;
Conformant_Array_Schema ::= Array Index_Type_Specification_aux Of Identifier_or_Conformant_Array_Schema;
Index_Type_Specification_aux1 ::= SemiColon Index_Type_Specification | Index_Type_Specification_aux | /*vazio*/;
Index_Type_Specification_aux ::= Index_Type_Specification Index_Type_Specification_aux1 | /*vazio*/;


expr_list ::= expr_list expr:e SEMICOLON         {: System.out.println(e); :}
            | expr:e SEMICOLON                   {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 MULTIPLY expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             %prec UMINUS
             | LPAR expr:e RPAR	         {: RESULT = e;           :}
             | NUMBER:n	                     {: RESULT = n;           :}
             ;
       
