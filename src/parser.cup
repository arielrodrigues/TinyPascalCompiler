package SintaxAnalizer;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
    ComplexSymbolfactory f = new ComplexSymbolfactory();
    symbolfactory = f;
    File file = new File("input.txt");
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    lexer = new Lexer(f,fis);
:};
scan with {:
    return lexer.next_token();
:};

/* terminals (tokens returned by the scanner). */

/* operadores aritmeticos */
terminal            PLUS, MINUS, MULTIPLY, DIVIDE;
/* symbols */
terminal			DOT, DOUBLEDOT, COMMA, COLON, SEMICOLON, CARET, ASSIGN;
terminal 			LPAR, RPAR, LBRA, RBRA, SINGLEQUOTES;
terminal 			LT,LE,GT,GE,EQUAL,DIFF;
/* reserved words */
terminal			ID,CHR,STR,COMMENT;
terminal			AND, ARRAY, ASM, BEGIN, BOOLEAN, CASE, CHAR, CONST, CONSTRUCTOR, DESTRUCTOR,
					DIV, DO, DOWNTO, ELSE, END, FALSE, FILE, FOR, FOWARD, FUNCTION, GOTO,
					IF, IMPLEMENTATION, IN, INLINE, INTEGER, INTERFACE, LABEL, MOD, NIL, NOT,
					OBJECT, OF, OR, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, SHL, SHR,
					STRING, THEN, TO, TRUE, TYPE, UNIT, UNTIL, USES, VAR, WHILE, WITH, XOR;
/* types */
terminal Integer    NUMINT;
terminal double 	NUMREAL;

/* Non terminals */

/* Program heading */
non terminal            program_heading,prog,block,id_list,label_declaration_part,label,type_definition_part;
/* Variables decalration */
non terminal 			variable_declaration_part,procedure_and_function_part,procedure_and_function_declaration_part,
                        procedure_and_function_declaration_aux,procedure_or_function_declaration;
/* Labels and Types */
non terminal			label_declaration_aux,type_definition_aux,type_definition,type_denoter,new_type,new_ordinary_type,array_type,
                        ordinal_type,ordinal_type_aux;
non terminal 			new_ordinal_type,enumerated_type,subRange_type,constant,character_string,string_element,string_element_aux,
                        string_character,variable_declaration,variable_declaration_aux;
/* procedure and Funciton Declaration */
non terminal 			procedure_declaration,function_declaration,procedure_heading,function_heading,procedure,function;
/* Parameter lists */
non terminal 			formal_parameter_list,result_type,formal_parameter_section,formal_parameter_section_aux;
/* Parameter Specification */
non terminal 			value_parameter_specification,variable_parameter_specification,conformant_Array_Parameter_Specification,
 			            value_conformant_array_specification,variable_conformant_array_specification,conformant_array_schema,
                        index_type_specification,index_type_specification_aux,identifier_or_conformant_array_schema;
/* Statements */
non terminal 			compound_statement,statement_sequence,statement_aux,statement,simple_or_structured_statement,
		                simple_statement,empty_statement,assignment_statement,variable_access,indexed_variable,expression_aux,
 			            procedure_statement,actual_parameter_list,actual_parameter_aux,actual_parameter,goto_statement,
                        structured_statement,if_statement,else_part,while_statement;
/* Expressions and Operations */
non terminal 			expression,relational_operator,expr_list,simple_expression,term_aux,term,factor_aux,factor,
			            multiplying_operator,adding_operator,unsigned_constant,function_Designator;
/* Sign and id list */
non terminal			Sign, id_list_aux;
/*** @CORRIGIR ***/
non terminal Integer    expr;      // used to store evaluated subexpressions

/* Precedences */
precedence nonassoc RBRA;	// Inserted by Eclipse plugin
precedence nonassoc SEMICOLON;	// Inserted by Eclipse plugin
precedence left PLUS,MINUS;
precedence left MULTIPLY,DIVIDE;

/* Grammar rules and sintatic evaluation */

/* program */
prog ::= program_heading SEMICOLON block DOT;
program_heading ::= PROGRAM ID | PROGRAM ID LPAR id_list RPAR;

/* identifier list */
id_list ::= ID id_list_aux;
id_list_aux ::= COMMA ID id_list_aux | /*vazio*/ ;

/* block */
block ::= label_declaration_part type_definition_part variable_declaration_part procedure_and_function_part compound_statement;

/* label */
label_declaration_part ::= LABEL label label_declaration_aux SEMICOLON | /*vazio*/; // optional
label_declaration_aux ::= COMMA label label_declaration_aux | /*vazio*/ ;
label ::= NUMINT ;

/* Type Definition */
type_definition_part ::= TYPE type_definition SEMICOLON type_definition_aux | /*vazio*/ ;
type_definition_aux ::= type_definition SEMICOLON type_definition_aux | /*vazio*/ ;
type_definition ::= ID EQUAL type_denoter;
type_denoter ::= ID | new_type;
new_type ::= new_ordinary_type | array_type;
array_type ::= ARRAY LBRA ordinal_type ordinal_type_aux RBRA OF type_denoter;
ordinal_type_aux ::= COMMA ordinal_type ordinal_type_aux | /*vazio*/;
ordinal_type ::= new_ordinal_type | ID;
new_ordinal_type ::= enumerated_type | subRange_type;
enumerated_type ::= LPAR id_list RPAR;
subRange_type ::= constant DOUBLEDOT constant;
Sign::= PLUS | MINUS | /*vazio*/ ;
constant ::= Sign NUMINT | character_string; // NUMINT -> UnsignedNumber
character_string ::= SINGLEQUOTES string_element string_element_aux SINGLEQUOTES; // string element ?
string_element_aux::= string_character string_element_aux | /*vazio*/;
string_character::= CHAR;

/* Variable Declaration */
variable_declaration_part ::= VAR variable_declaration SEMICOLON variable_declaration_aux | /*vazio*/;
variable_declaration_aux ::= variable_declaration SEMICOLON variable_declaration_aux | /*vazio*/;
variable_declaration ::= id_list COLON type_denoter;

/* procedure and function Declaration*/
procedure_and_function_declaration_part ::= procedure_and_function_declaration_aux ;
procedure_and_function_declaration_aux ::= procedure_or_function_declaration SEMICOLON procedure_and_function_declaration_aux | /*vazio*/ ;
procedure_or_function_declaration ::= procedure_declaration | function_declaration ;
procedure_declaration ::= procedure_heading SEMICOLON block;
function_declaration ::= function_heading SEMICOLON block;
procedure_heading ::= PROCEDURE ID | PROCEDURE ID formal_parameter_list;
function_heading ::= FUNCTION ID COLON result_type | FUNCTION ID formal_parameter_list COLON result_type;
function_Designator ::= /*function_identifier*/ ID | ID /*function_identifier*/ actual_parameter_list ;

/* Parameter List and Section */
formal_parameter_list ::= LPAR formal_parameter_section formal_parameter_section_aux RPAR;
formal_parameter_section_aux ::= SEMICOLON formal_parameter_section formal_parameter_section_aux | /*vazio*/ ;
formal_parameter_section ::= value_parameter_specification | variable_parameter_specification | conformant_Array_Parameter_Specification;

/* Parameter and identifier Specification */
value_parameter_specification::= id_list COLON ID;
variable_parameter_specification ::= VAR id_list COLON ID;
conformant_Array_Parameter_Specification ::= value_conformant_array_specification | variable_conformant_array_specification;
value_conformant_array_specification::= id_list COLON conformant_array_schema;
variable_conformant_array_specification ::= VAR id_list COLON conformant_array_schema;
conformant_array_schema ::= ARRAY LBRA index_type_specification index_type_specification_aux RBRA OF identifier_or_conformant_array_schema;
identifier_or_conformant_array_schema ::= ID | conformant_array_schema ;
index_type_specification_aux ::= SEMICOLON index_type_specification index_type_specification_aux | /*vazio*/;
index_type_specification ::= ID DOUBLEDOT ID COLON ID /*ordinal_type_identifier*/ ;

/* Compound statement */
compound_statement ::= BEGIN statement_sequence END ;
statement_sequence ::= statement statement_aux ;
statement_aux ::= SEMICOLON statement statement_aux | /*vazio*/ ;
statement ::= label COLON simple_or_structured_statement
        | simple_or_structured_statement ;
simple_or_structured_statement ::= simple_statement | structured_statement ;

/* Simple statement */
simple_statement ::= empty_statement | assignment_statement
        | procedure_statement | goto_statement ;
empty_statement ::= /*vazio*/ ;
assignment_statement ::= variable_access ASSIGN expression ;
variable_access ::= ID | indexed_variable ;
indexed_variable ::= variable_access LBRA expression expression_aux RBRA ;
expression_aux ::= COMMA expression expression_aux | /*vazio*/ ;
procedure_statement ::= /*procedure_identifier*/ ID | /*procedure_identifier*/ ID actual_parameter_list ;
actual_parameter_list ::= LPAR actual_parameter actual_parameter_aux RPAR ;
actual_parameter_aux ::= COMMA actual_parameter actual_parameter_aux | /*vazio*/ ;
actual_parameter ::= expression | variable_access ;
goto_statement ::= GOTO label ;

/* Structured statement */
structured_statement ::= compound_statement | if_statement | while_statement ;
if_statement ::= IF expression THEN statement
        | IF expression THEN statement else_part ;
else_part ::= ELSE statement ;
while_statement ::= WHILE expression DO statement ;

/* expression */
expression ::= simple_expression | simple_expression relational_operator simple_expression ;
simple_expression ::= Sign term term_aux ;
term_aux ::= adding_operator term term_aux | /*vazio*/ ;
term ::= factor factor_aux ;
factor_aux ::= multiplying_operator factor factor_aux | /*vazio*/ ;
factor ::= variable_access | unsigned_constant | function_Designator
        | LPAR expression RPAR | NOT factor ;

/* Operations */
multiplying_operator ::= MULTIPLY | DIVIDE | MOD | AND ;
adding_operator ::= PLUS | MINUS | OR ;
relational_operator ::= LT | LE | GT | GE | EQUAL | DIFF ;
unsigned_constant ::= NUMINT | character_string ;
